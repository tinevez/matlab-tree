
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Special trees and special methods</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-06-11"><meta name="DC.source" content="TreeDemo_special.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Special trees and special methods</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Special trees</a></li><li><a href="#3">Special methods</a></li><li><a href="#5">Condensing / decondensing a tree</a></li></ul></div><p>This is a bit of an interlude. We list here the methods that generate trees and in a particular way that do not fit with the rest of the tutorial.</p><p>We will use a subtree of the <tt>lineage</tt> tree as an example:</p><pre class="codeinput">lineage = tree.example;
t = lineage.subtree(19);
disp(t.tostring)
</pre><pre class="codeoutput">                EMS                 
     +-----------+-----+            
     |                 |            
    MS                 E            
  +--+--+        +-----+-----+      
  |     |        |           |      
MS.a  MS.p      E.a         E.p     
              +--+--+     +--+--+   
              |     |     |     |   
            E.al  E.ar  E.pl  E.pr  
</pre><h2>Special trees<a name="2"></a></h2><p>There are a few special trees that can be generated from a mother tree. They will have the same structure, but have different content, reflecting some properties of the mother tree.</p><p>Actually, right now there is only one such tree, which is the depth tree. The depth tree  simply holds the depth of each node. The depth itself is defined as the number of edges you must follow upward from the node to reach the root:</p><pre class="codeinput">dt = t.depthtree;
disp(dt.tostring)
</pre><pre class="codeoutput">        0         
  +-----+--+      
  |        |      
  1        1      
 ++-+   +--+--+   
 |  |   |     |   
 2  2   2     2   
       ++-+  ++-+ 
       |  |  |  | 
       3  3  3  3 
</pre><h2>Special methods<a name="3"></a></h2><p>The methods we have seen in the <i>Operators</i> section of the tutorial just compute a result depending only on the "local" node. They do not take into account the tree structure, such as the node's parent and children.</p><p>One method does that: <b><tt>recursivecumfun</tt></b>. At each node, this method applies a function to all the children of a node, store the results there, and repeat <i>recursively</i> from bottom to top.</p><p>For instance, one way to compute the total number of children a node has (including itself) is the following:</p><pre class="codeinput">ot = tree(t, 1); <span class="comment">% Create a copy-tree filled with ones</span>
nc = ot.recursivecumfun(@(x) sum(x) + 1);
disp( [ t.tostring nc.tostring ] )
</pre><pre class="codeoutput">                EMS                        11         
     +-----------+-----+              +-----+--+      
     |                 |              |        |      
    MS                 E              3        7      
  +--+--+        +-----+-----+       ++-+   +--+--+   
  |     |        |           |       |  |   |     |   
MS.a  MS.p      E.a         E.p      1  1   3     3   
              +--+--+     +--+--+          ++-+  ++-+ 
              |     |     |     |          |  |  |  | 
            E.al  E.ar  E.pl  E.pr         1  1  1  1 
</pre><p>Note that for this method, the resulting tree depends only on the structure of the input and of the content of its leaf nodes. The content of the other nodes is ignored by construction.</p><h2>Condensing / decondensing a tree<a name="5"></a></h2><p>Sometimes, I have trees where most of the nodes have only one child, with the exact same content. This happens for instance when you capture the life of a cell in several discrete frames. When the cell, observed in one frame, does not divide, I simply add a single node to the parent node, and resume. This can lead to trees that are like this:</p><pre class="codeinput">t = tree(<span class="string">'AB'</span>);
[t, index] = t.addnode(0, <span class="string">'AB'</span>);
[t, index] = t.addnode(index, <span class="string">'AB'</span>);
[t, index] = t.addnode(index, <span class="string">'AB'</span>);

[t, ia] = t.addnode(index, <span class="string">'ABa'</span>);
[t, ia] = t.addnode(ia, <span class="string">'ABa'</span>);
[t, ia] = t.addnode(ia, <span class="string">'ABa'</span>);
[t, ia] = t.addnode(ia, <span class="string">'ABa'</span>);

[t, ib] = t.addnode(index, <span class="string">'ABb'</span>);
[t, ib] = t.addnode(ib, <span class="string">'ABb'</span>);
[t, ib] = t.addnode(ib, <span class="string">'ABb'</span>);
[t, ib] = t.addnode(ib, <span class="string">'ABb'</span>);
[t, ib] = t.addnode(ib, <span class="string">'ABb'</span>);
[t, ib] = t.addnode(ib, <span class="string">'ABb'</span>);

disp(t.tostring)
</pre><pre class="codeoutput">   AB     
          
    |     
   AB     
          
    |     
   AB     
  +-+--+  
  |    |  
 ABa  ABb 
  |    |  
  |    |  
 ABa  ABb 
  |    |  
  |    |  
 ABa  ABb 
  |    |  
  |    |  
 ABa  ABb 
       |  
       |  
      ABb 
       |  
       |  
      ABb 
</pre><p>Condensing allows to simplify the content tree, and extract the repetition length:</p><pre class="codeinput">[vt, lt] = condense(t);
disp([ vt.tostring lt.tostring ])
</pre><pre class="codeoutput">   AB       3   
  +-+--+   ++-+ 
  |    |   |  | 
 ABa  ABb  4  6 
</pre><p>De-condensing is of course just the opposite:</p><pre class="codeinput">nt = decondense(vt, lt);
disp(nt.tostring)
</pre><pre class="codeoutput">   AB     
          
    |     
   AB     
          
    |     
   AB     
  +-+--+  
  |    |  
 ABa  ABb 
  |    |  
  |    |  
 ABa  ABb 
  |    |  
  |    |  
 ABa  ABb 
  |    |  
  |    |  
 ABa  ABb 
       |  
       |  
      ABb 
       |  
       |  
      ABb 
</pre><p>Back to <a href="../index.html">main page</a>.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Special trees and special methods

%% 
% This is a bit of an interlude. We list here the methods that generate
% trees and in a particular way that do not fit with the rest of the
% tutorial.
% 
% We will use a subtree of the |lineage| tree as an example:

lineage = tree.example;
t = lineage.subtree(19);
disp(t.tostring)


%% Special trees
%
% There are a few special trees that can be generated from a mother tree.
% They will have the same structure, but have different content, reflecting
% some properties of the mother tree.
%
% Actually, right now there is only one such tree, which is the depth tree.
% The depth tree  simply holds the depth of each node. The depth itself is
% defined as the number of edges you must follow upward from the node to
% reach the root:

dt = t.depthtree;
disp(dt.tostring)





%% Special methods
%
% The methods we have seen in the _Operators_ section of the tutorial just
% compute a result depending only on the "local" node. They do not take
% into account the tree structure, such as the node's parent and children.
%
% One method does that: *|recursivecumfun|*. At each node, this method
% applies a function to all the children of a node, store the results
% there, and repeat _recursively_ from bottom to top.
%
% For instance, one way to compute the total number of children a node has
% (including itself) is the following:

ot = tree(t, 1); % Create a copy-tree filled with ones
nc = ot.recursivecumfun(@(x) sum(x) + 1);
disp( [ t.tostring nc.tostring ] )

%%
% Note that for this method, the resulting tree depends only on the
% structure of the input and of the content of its leaf nodes. The content
% of the other nodes is ignored by construction.



%% Condensing / decondensing a tree
%
% Sometimes, I have trees where most of the nodes have only one child, with
% the exact same content. This happens for instance when you capture the
% life of a cell in several discrete frames. When the cell, observed in one
% frame, does not divide, I simply add a single node to the parent node,
% and resume. This can lead to trees that are like this:

t = tree('AB');
[t, index] = t.addnode(0, 'AB');
[t, index] = t.addnode(index, 'AB');
[t, index] = t.addnode(index, 'AB');

[t, ia] = t.addnode(index, 'ABa');
[t, ia] = t.addnode(ia, 'ABa');
[t, ia] = t.addnode(ia, 'ABa');
[t, ia] = t.addnode(ia, 'ABa');

[t, ib] = t.addnode(index, 'ABb');
[t, ib] = t.addnode(ib, 'ABb');
[t, ib] = t.addnode(ib, 'ABb');
[t, ib] = t.addnode(ib, 'ABb');
[t, ib] = t.addnode(ib, 'ABb');
[t, ib] = t.addnode(ib, 'ABb');

disp(t.tostring)

%%
% Condensing allows to simplify the content tree, and extract the
% repetition length:

[vt, lt] = condense(t);
disp([ vt.tostring lt.tostring ])

%%
% De-condensing is of course just the opposite:

nt = decondense(vt, lt);
disp(nt.tostring)



%%
% Back to <TreeDemo.html main page>.


##### SOURCE END #####
--></body></html>